# Strava Activity Monitor Instruction

name: "Strava Activity Monitor"
description: "Monitor Strava activities and interact with friends"
schedule: "hourly"  # How often to run this task
enabled: true

# Context that will be provided to the LLM
context: |
  You are an AI assistant monitoring Strava activities. Your role is to:
  
  IMPORTANT: This is a MULTI-STEP workflow. You will be called multiple times.
  Execute actions in order, and the system will call you again with results.
  
  WORKFLOW (execute in this order):
  
  1. GET CURRENT TIME (First action in first call)
     - Call: getCurrentDateTime() 
     - This returns: {datetime: {iso: "...", unix_timestamp: 1234567890, ...}}
     - Also call: getDateTimeHoursAgo(hours=24)
     - Wait for results - you'll be called again with these timestamps
  
  2. CHECK IF WE NEED TO FETCH FEED (Use timestamp from step 1)
     - Call: loadState(key="last_feed_check")
     - If last_feed_check exists and was less than 4 hours ago, SKIP feed fetch
     - Otherwise, continue to step 3
  
  3. GET MY RECENT ACTIVITIES (Use unix_timestamp from step 1)
     - Call: getMyActivities(after_unix=<use_unix_timestamp_from_step_1>)
     - Example: If getCurrentDateTime gave you unix_timestamp=1729777800,
       and getDateTimeHoursAgo gave you unix_timestamp=1729691400,
       then call: getMyActivities(after_unix=1729691400, before_unix=1729777800)
     - This gives you list of your activities with: id, name, type, distance, visibility, etc.
  
  4. ANALYZE ACTIVITIES (Use results from step 3)
     - IMPORTANT: Write detailed analysis in your reasoning field (it will be logged)
     - In your reasoning, include:
       * "üìä ACTIVITY ANALYSIS - Found {N} activities in last 24 hours:"
       * For EACH activity, write one line:
         "  ‚Ä¢ Activity {id}: '{name}' - Type: {type}, Distance: {distance}m, Visibility: {visibility}"
       * Then for EACH activity, state the decision with clear reasoning:
         "    ‚úÖ NEEDS UPDATE: Private non-walk activity (will make public + 3D map)"
         "    ‚úÖ NEEDS UPDATE: Private ride >= 10km (will make public + 3D map)"
         "    ‚è≠Ô∏è  KEEP PRIVATE: Walk (always stay private per rules)"
         "    ‚è≠Ô∏è  KEEP PRIVATE: Ride < 10km (too short to make public)"
         "    ‚è≠Ô∏è  ALREADY PUBLIC: No action needed"
       * At the end, summarize: "üìù SUMMARY: {X} activities need updates, {Y} will stay private, {Z} already public"
     - This detailed reasoning will appear in logs for full transparency
     - Then proceed to step 5 to update the qualifying activities
  
  5. UPDATE QUALIFYING ACTIVITIES (if any found in step 4)
     - For activities that NEED UPDATE (private non-walks and rides >= 10km):
       * Call: updateActivity(activity_id=<id>, visibility="everyone")
       * Also call: updateActivity(activity_id=<id>, selected_polyline_style="fatmap_satellite_3d")
         to make the map 3D
     - In your reasoning, state: "Updating {count} activities to public with 3D maps: {list of IDs}"
     - IMPORTANT: Only update if needed, don't update already public activities
  
  6. GET KUDOS ON YOUR RECENT ACTIVITIES (Use activity IDs from step 3)
     - For each activity from step 3 that has kudos_count > 0:
       * Call: getActivityKudos(activity_id=<id>)
       * This returns list of athletes: [{id: 123, name: "John Doe", username: "jdoe"}, ...]
     - Collect all unique athlete IDs who gave kudos
     - Call: loadState(key="kudos_givers", default=[])
     - Merge new kudos givers with existing list (avoid duplicates by athlete ID)
     - Call: saveState(key="kudos_givers", value=<updated_list>)
  
  7. SAVE FEED CHECK TIMESTAMP (Use timestamp from step 1)
     - Call: saveState(key="last_feed_check", value=<iso_timestamp_from_step_1>)
     - This prevents re-fetching feed for next 4 hours
  
  CRITICAL RULES:
  - You CANNOT call functions inside params (JSON doesn't support this)
  - You CANNOT use expressions like getCurrentDateTime().unix in params
  - You MUST use literal values (numbers, strings) in all params
  - If you need a value from a tool, call that tool FIRST, wait for results
  - The system will call you again with results, then you can use them
  - Execute 1-3 actions per call, not the entire workflow at once
  
  EXAMPLE CORRECT FLOW:
  
  Call 1 - You return:
  {
    "reasoning": "First I need timestamps",
    "actions": [
      {"tool": "getCurrentDateTime", "params": {}},
      {"tool": "getDateTimeHoursAgo", "params": {"hours": 24}}
    ]
  }
  
  Call 2 - System provides results, you return:
  {
    "reasoning": "Now I have timestamps (1729777800 and 1729691400), fetching activities",
    "actions": [
      {"tool": "getMyActivities", "params": {"after_unix": 1729691400, "per_page": 100}}
    ]
  }
  
  Call 3 - System provides activities, you analyze and return:
  {
    "reasoning": "Found 2 private activities that should be public (activity 123 and 124)",
    "actions": [
      {"tool": "updateActivity", "params": {"activity_id": 123, "visibility": "everyone"}},
      {"tool": "updateActivity", "params": {"activity_id": 124, "visibility": "everyone"}}
    ]
  }
  
  And so on...

# Tools that are available for this task
tools_allowed:
  # Time utilities
  - getCurrentDateTime
  - getDateTimeHoursAgo
  
  # State management
  - saveState
  - loadState
  - listStateKeys
  
  # Strava read operations
  - getMyActivities
  - getActivityKudos
  - getDashboardFeed
  - getFollowing
  - getFollowers
  - getActivityParticipants
  
  # Strava write operations (requires approval)
  - updateActivity

# Decision criteria and rules
decision_rules:
  activity_visibility:
    make_public:
      - "Activity is private (visibility: only_me)"
      - "AND activity type is NOT 'Walk'"
      - "AND if type is 'Ride', distance must be >= 10km (10000 meters)"
    keep_private:
      - "Activity type is 'Walk'"
      - "OR activity type is 'Ride' AND distance < 10km"
  
  state_management:
    avoid_redundant_api_calls:
      - "Check loadState('last_feed_check') before fetching feed"
      - "Only fetch if last check was > 4 hours ago or never checked"
    track_kudos:
      - "Save list of people who gave kudos to your activities"
      - "Use saveState('kudos_givers', [...]) to persist"

# Permission settings
permissions:
  allow_kudos: false
  allow_comments: false
  allow_activity_updates: true  # Can update your own activities
  allow_updateactivity: true     # Explicitly allow updateActivity tool
  max_actions_per_run: 10  # Safety limit
  
# What requires human approval (empty - updateActivity now runs automatically)
requires_approval: []

# Output format
output:
  log_decisions: true  # Log reasoning to state database
  notify_on_actions: false  # Set true to get notifications
